pipeline {
  agent any
  environment {
    GIT_URL = "https://github.com/ittipol/Database-Change-Log.git"
    GIT_CREDENTIAL = "git-cred"
    GIT_PATH = "./non-prod/sit"

    // env config
    DB_PATH = "./src/non-prod/sit/database_b"
  }
  parameters {
    choice(name: 'DB_ENV', choices:['sit', 'uat'])
    string(name: 'TAG_VERSION', defaultValue: '2.0.0', description: 'Tag version')
    booleanParam(name: 'CHECK_TAG_VERSION', defaultValue: true, description: 'Only check for tag existence')
  }
  options {
    // This is required if you want to clean before build
    skipDefaultCheckout(true)
  }
  stages {
    stage('Init') {
      steps {
        echo '::: Init ************************************************************'
        // Clean before build
        cleanWs()
        echo "Building ${env.JOB_NAME}..."

        script {
          if(params.TAG_VERSION.isEmpty() || params.TAG_VERSION.endsWith("/")) {
            error("TAG_VERSION parameter is not valid")
          }
        }

        sh "mkdir -p $WORKSPACE/liquibase"
        sh 'cp -rf /var/jenkins_home/db/. $WORKSPACE/src'

        // sh 'env'
      }
    }
    // stage('SCM Checkout') {
    //   steps {
    //     echo '::: SCM Checkout ************************************************************'
    //     // We need to explicitly checkout from SCM here
    //     // ‘checkout scm’ is only available when using “Multibranch Pipeline” or “Pipeline script from SCM”
    //     // checkout scm
    //     git branch: 'main', changelog: false, credentialsId: env.GIT_CREDENTIAL, poll: false, url: env.GIT_URL
    //   }
    // }
    stage('Check for folder existence') {
      steps {
        script {
          if (fileExists(DB_PATH)) {
            echo "Folder '$DB_PATH' found in the workspace!"
          } else {
            // echo "Folder '$DB_PATH' not found"
            error("Folder '$DB_PATH' not found")
          }
        }
      }
    }    
    stage('Check configs') {
      steps {
        script {

          def changeLogPath = "${DB_PATH}/config/liquibase.changelog.yml"
          echo "${changeLogPath}"

          if (fileExists(changeLogPath)) {
            echo "File '$changeLogPath' found!"

            sh """
            cp $changeLogPath $WORKSPACE/liquibase/liquibase.changelog.yml
            """

          } else {
            // echo "File '$changeLogPath' not found"
            error("File '$changeLogPath' not found")
          }

          def liquibasePropertyPath = "${DB_PATH}/config/liquibase.properties"
          echo "${liquibasePropertyPath}"

          if (fileExists(liquibasePropertyPath)) {
            echo "File '$liquibasePropertyPath' found!"

            sh """
            cp $liquibasePropertyPath $WORKSPACE/liquibase/liquibase.properties
            """

          } else {
            // echo "File '$liquibasePropertyPath' not found"
            error("File '$liquibasePropertyPath' not found")
          }
        }
      }
    }
    stage('Validate Changelog') {
      steps {
        sh """
        cd $WORKSPACE/liquibase && liquibase validate
        """
      }
      post {
        failure {
          echo "Build stage failed!"
          error("Build stage failed!")
        }
      }
    }
    stage('Check for tag version existence') {
      steps {

        script {
          dir("$WORKSPACE/liquibase") {
            sh '''
            liquibase history --format=TEXT --show-tags=true --tag-filter="${TAG_VERSION}" | grep -i "Applied 1 changeset" && { echo "The tag '${TAG_VERSION}' already exist"; exit 1; } || echo "The tag '${TAG_VERSION}' does NOT exist"
            '''
          }
        }

        // sh '''
        //   cd $WORKSPACE/liquibase && liquibase tag-exists --tag="${TAG_VERSION}"
        // '''
      }
      post {
        failure {
          echo "Build stage failed!"
          error("Build stage failed!")
        }
      }
    }
    stage('Tag Database') {
      when {
        expression {
          params.CHECK_TAG_VERSION == false
        }
      }
      steps {
        sh 'cd $WORKSPACE/liquibase && liquibase tag "${TAG_VERSION}"'
      }
    }
  }
  post {
    always {
      echo '::: Post ************************************************************'

      cleanWs(cleanWhenNotBuilt: false,
              deleteDirs: true, // Set to true if you want to delete empty directories after cleanup
              disableDeferredWipeout: true,
              notFailBuild: true, // Set to true to prevent the build from failing if cleanup encounters issues
              patterns: [
                [pattern: '.git/**', type: 'INCLUDE'], // INCLUDE the entire .git directory and its contents
                [pattern: 'src/**', type: 'INCLUDE'],
                [pattern: 'liquibase/**', type: 'INCLUDE'],
                // [pattern: 'liquibase/migrations/**', type: 'INCLUDE'],
                // [pattern: 'liquibase/liquibase.*', type: 'INCLUDE'],
                // [pattern: 'liquibase/*.sql', type: 'EXCLUDE'], // Exclude all .sql files within the 'target' directory
                // [pattern: 'liquibase/update.log', type: 'EXCLUDE'] // Exclude a specific file
              ]
            )
    }
    failure {
      // Optional: Implement rollback on failure
      // script {
      //   echo "Liquibase update failed. Consider rolling back."
      //   // sh "liquibase rollback-count 1 --label-filter $CARD_NUMBER"
      // }
      echo "Build ID: ${BUILD_ID}, ${JOB_NAME} failed"
    }
  }
}